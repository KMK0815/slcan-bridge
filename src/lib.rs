#![no_std]
#![no_main]

use bxcan;
use core::fmt::Write;
use cortex_m_semihosting::debug;
use embedded_hal::can::{ExtendedId, Frame, Id, StandardId};
use heapless::Vec;
use slcan_parser::CanserialFrame;

use defmt_rtt as _; // global logger

// our hal
use embassy_stm32 as _;

use panic_probe as _;

// same panicking *behavior* as `panic-probe` but doesn't print a panic message
// this prevents the panic message being printed *twice* when `defmt::panic` is invoked
#[defmt::panic_handler]
fn panic() -> ! {
    cortex_m::asm::udf()
}

/// Terminates the application and makes a semihosting-capable debug tool exit
/// with status code 0.
pub fn exit() -> ! {
    loop {
        debug::exit(debug::EXIT_SUCCESS);
    }
}

/// Hardfault handler.
///
/// Terminates the application and makes a semihosting-capable debug tool exit
/// with an error. This seems better than the default, which is to spin in a
/// loop.
#[cortex_m_rt::exception]
unsafe fn HardFault(_frame: &cortex_m_rt::ExceptionFrame) -> ! {
    loop {
        debug::exit(debug::EXIT_FAILURE);
    }
}

/// Convert `CanFrame` to `Vec` containing ascii string generated by a `CanserialFrame`
pub fn bxcan_to_vec(bxcan_frame: &bxcan::Frame) -> Option<Vec<u8, 32>> {
    let frame = bxcan_to_canserial(bxcan_frame)?;
    // longest canserial ascii string for an extended id frame is 26 bytes
    let mut buffer: Vec<u8, 32> = Vec::new();
    core::write!(&mut buffer, "{}\r", frame).ok();
    Some(buffer)
}

/// Convert `bxcan::Id` to `Id`
///
/// bxcan doesn't use embedded_hal
pub fn bxcan_to_canserial_id(id: &bxcan::Id) -> Option<Id> {
    match id {
        bxcan::Id::Standard(stdid) => match StandardId::new(stdid.as_raw()) {
            Some(id) => Some(Id::Standard(id)),
            None => None,
        },
        bxcan::Id::Extended(extid) => match ExtendedId::new(extid.as_raw()) {
            Some(id) => Some(Id::Extended(id)),
            None => None,
        },
    }
}

/// Convert `Id` to `bxcan::Id`
///
/// bxcan doesn't use embedded_hal
pub fn canserial_to_bxcan_id(id: &Id) -> Option<bxcan::Id> {
    match id {
        Id::Standard(stdid) => match bxcan::StandardId::new(stdid.as_raw()) {
            Some(id) => Some(bxcan::Id::Standard(id)),
            None => None,
        },
        Id::Extended(extid) => match bxcan::ExtendedId::new(extid.as_raw()) {
            Some(id) => Some(bxcan::Id::Extended(id)),
            None => None,
        },
    }
}

/// Convert `CanserialFrame` to `bxcan::Frame` for use with bcan driver
pub fn canserial_to_bxcan(slcan: &CanserialFrame) -> Option<bxcan::Frame> {
    match slcan.is_remote_frame() {
        true => Some(bxcan::Frame::new_remote(
            canserial_to_bxcan_id(&slcan.id())?,
            slcan.dlc() as u8,
        )),
        false => Some(bxcan::Frame::new_data(
            canserial_to_bxcan_id(&slcan.id())?,
            bxcan::Data::new(slcan.data())?,
        )),
    }
}

/// Convert `bxcan::Frame` to `CanserialFrame` for use with serial port
pub fn bxcan_to_canserial(bcanframe: &bxcan::Frame) -> Option<CanserialFrame> {
    match bcanframe.is_remote_frame() {
        true => CanserialFrame::new_remote(
            bxcan_to_canserial_id(&bcanframe.id())?,
            bcanframe.dlc() as usize,
        ),
        false => {
            let data = bcanframe.data().unwrap();
            CanserialFrame::new_frame(
                bxcan_to_canserial_id(&bcanframe.id())?,
                data.get(0..data.len())?,
            )
        }
    }
}
